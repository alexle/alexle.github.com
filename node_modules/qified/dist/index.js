import{Hookified as d}from"hookified";var p="@qified/memory",o=class{_subscriptions;_id;constructor(s){this._subscriptions=new Map,this._id=s?.id??p}get id(){return this._id}set id(s){this._id=s}get subscriptions(){return this._subscriptions}set subscriptions(s){this._subscriptions=s}async publish(s,i){let e={...i,providerId:this._id},r=this._subscriptions.get(s)??[];for(let a of r)await a.handler(e)}async subscribe(s,i){this._subscriptions.has(s)||this._subscriptions.set(s,[]),this._subscriptions.get(s)?.push(i)}async unsubscribe(s,i){if(i){let e=this._subscriptions.get(s);e&&this._subscriptions.set(s,e.filter(r=>r.id!==i))}else this._subscriptions.delete(s)}async disconnect(){this._subscriptions.clear()}};var u=(t=>(t.error="error",t.info="info",t.warn="warn",t.publish="publish",t.subscribe="subscribe",t.unsubscribe="unsubscribe",t.disconnect="disconnect",t))(u||{}),n=class extends d{_messageProviders=[];constructor(s){super(s),s?.messageProviders&&(this._messageProviders=s.messageProviders)}get messageProviders(){return this._messageProviders}set messageProviders(s){this._messageProviders=s}async subscribe(s,i){try{let e=this._messageProviders.map(async r=>r.subscribe(s,i));await Promise.all(e),this.emit("subscribe",{topic:s,handler:i})}catch(e){this.emit("error",e)}}async publish(s,i){try{let e=this._messageProviders.map(async r=>r.publish(s,i));await Promise.all(e),this.emit("publish",{topic:s,message:i})}catch(e){this.emit("error",e)}}async unsubscribe(s,i){try{let e=this._messageProviders.map(async r=>r.unsubscribe(s,i));await Promise.all(e),this.emit("unsubscribe",{topic:s,id:i})}catch(e){this.emit("error",e)}}async disconnect(){try{let s=this._messageProviders.map(async i=>i.disconnect());await Promise.all(s),this._messageProviders=[],this.emit("disconnect")}catch(s){this.emit("error",s)}}};export{o as MemoryMessageProvider,n as Qified,u as QifiedEvents};
