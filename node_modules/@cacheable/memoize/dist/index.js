import{coalesceAsync as l,hash as p}from"@cacheable/utils";function d(n,t){let{ttl:e,keyPrefix:a,cache:r,serialize:c}=t;return(...s)=>{let i=u(n,s,{keyPrefix:a,serialize:c});t.createKey&&(i=t.createKey(n,s,t));let y=r.get(i);if(y===void 0)try{y=n(...s),r.set(i,y,e)}catch(o){r.emit("error",o),t.cacheErrors&&r.set(i,o,e)}return y}}async function g(n,t,e){let a=typeof n=="function"?n(e):n,r=await e.cache.get(a);if(r===void 0){let s=`${e.cacheId??"default"}::${a}`;r=await l(s,async()=>{try{let i=await t();return await e.cache.set(a,i,e.ttl),i}catch(i){if(e.cache.emit("error",i),e.cacheErrors&&await e.cache.set(a,i,e.ttl),e.throwErrors)throw i}})}return r}function f(n,t){let{keyPrefix:e,serialize:a}=t;return async(...r)=>{let c=u(n,r,{keyPrefix:e,serialize:a});return t.createKey&&(c=t.createKey(n,r,t)),g(c,async()=>n(...r),t)}}function u(n,t,e){let{keyPrefix:a,serialize:r}=e||{};return a?`${a}::${n.name}::${p(t,{serialize:r})}`:`${n.name}::${p(t,{serialize:r})}`}export{u as createWrapKey,g as getOrSet,f as wrap,d as wrapSync};
