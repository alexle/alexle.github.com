"use strict";var p=Object.defineProperty;var S=Object.getOwnPropertyDescriptor;var C=Object.getOwnPropertyNames;var T=Object.prototype.hasOwnProperty;var z=(i,e)=>{for(var t in e)p(i,t,{get:e[t],enumerable:!0})},x=(i,e,t,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of C(e))!T.call(i,s)&&s!==t&&p(i,s,{get:()=>e[s],enumerable:!(r=S(e,s))||r.enumerable});return i};var H=i=>x(p({},"__esModule",{value:!0}),i);var M={};z(M,{CacheableMemory:()=>a,HashAlgorithm:()=>l.HashAlgorithm,KeyvCacheableMemory:()=>u,createKeyv:()=>g,defaultStoreHashSize:()=>y,hash:()=>l.hash,hashToNumber:()=>l.hashToNumber,maximumMapSize:()=>c});module.exports=H(M);var b=require("@cacheable/memoize"),o=require("@cacheable/utils"),_=require("hookified");var m=class{value;prev=void 0;next=void 0;constructor(e){this.value=e}},h=class{head=void 0;tail=void 0;nodesMap=new Map;addToFront(e){let t=new m(e);this.head?(t.next=this.head,this.head.prev=t,this.head=t):this.head=this.tail=t,this.nodesMap.set(e,t)}moveToFront(e){let t=this.nodesMap.get(e);!t||this.head===t||(t.prev&&(t.prev.next=t.next),t.next&&(t.next.prev=t.prev),t===this.tail&&(this.tail=t.prev),t.prev=void 0,t.next=this.head,this.head&&(this.head.prev=t),this.head=t,this.tail??=t)}getOldest(){return this.tail?this.tail.value:void 0}removeOldest(){if(!this.tail)return;let e=this.tail.value;return this.tail.prev?(this.tail=this.tail.prev,this.tail.next=void 0):this.head=this.tail=void 0,this.nodesMap.delete(e),e}get size(){return this.nodesMap.size}};var l=require("@cacheable/utils");var f=require("keyv");var u=class{opts={ttl:0,useClone:!0,lruSize:0,checkInterval:0};_defaultCache=new a;_nCache=new Map;_namespace;constructor(e){e&&(this.opts=e,this._defaultCache=new a(e),e.namespace&&(this._namespace=e.namespace,this._nCache.set(this._namespace,new a(e))))}get namespace(){return this._namespace}set namespace(e){this._namespace=e}get store(){return this.getStore(this._namespace)}async get(e){let t=this.getStore(this._namespace).get(e);if(t)return t}async getMany(e){return this.getStore(this._namespace).getMany(e)}async set(e,t,r){this.getStore(this._namespace).set(e,t,r)}async setMany(e){this.getStore(this._namespace).setMany(e)}async delete(e){return this.getStore(this._namespace).delete(e),!0}async deleteMany(e){return this.getStore(this._namespace).deleteMany(e),!0}async clear(){this.getStore(this._namespace).clear()}async has(e){return this.getStore(this._namespace).has(e)}on(e,t){return this.getStore(this._namespace).on(e,t),this}getStore(e){return e?(this._nCache.has(e)||this._nCache.set(e,new a(this.opts)),this._nCache.get(e)):this._defaultCache}};function g(i){let e=new u(i),t=i?.namespace,r;i?.ttl&&Number.isInteger(i.ttl)&&(r=i?.ttl);let s=new f.Keyv({store:e,namespace:t,ttl:r});return s.serialize=void 0,s.deserialize=void 0,s}var y=16,c=16777216,a=class extends _.Hookified{_lru=new h;_storeHashSize=y;_storeHashAlgorithm=o.HashAlgorithm.DJB2;_store=Array.from({length:this._storeHashSize},()=>new Map);_ttl;_useClone=!0;_lruSize=0;_checkInterval=0;_interval=0;constructor(e){super(),e?.ttl&&this.setTtl(e.ttl),e?.useClone!==void 0&&(this._useClone=e.useClone),e?.storeHashSize&&e.storeHashSize>0&&(this._storeHashSize=e.storeHashSize),e?.lruSize&&(e.lruSize>c?this.emit("error",new Error(`LRU size cannot be larger than ${c} due to Map limitations.`)):this._lruSize=e.lruSize),e?.checkInterval&&(this._checkInterval=e.checkInterval),e?.storeHashAlgorithm&&(this._storeHashAlgorithm=e.storeHashAlgorithm),this._store=Array.from({length:this._storeHashSize},()=>new Map),this.startIntervalCheck()}get ttl(){return this._ttl}set ttl(e){this.setTtl(e)}get useClone(){return this._useClone}set useClone(e){this._useClone=e}get lruSize(){return this._lruSize}set lruSize(e){if(e>c){this.emit("error",new Error(`LRU size cannot be larger than ${c} due to Map limitations.`));return}if(this._lruSize=e,this._lruSize===0){this._lru=new h;return}this.lruResize()}get checkInterval(){return this._checkInterval}set checkInterval(e){this._checkInterval=e}get size(){let e=0;for(let t of this._store)e+=t.size;return e}get storeHashSize(){return this._storeHashSize}set storeHashSize(e){e!==this._storeHashSize&&(this._storeHashSize=e,this._store=Array.from({length:this._storeHashSize},()=>new Map))}get storeHashAlgorithm(){return this._storeHashAlgorithm}set storeHashAlgorithm(e){this._storeHashAlgorithm=e}get keys(){let e=[];for(let t of this._store)for(let r of t.keys()){let s=t.get(r);if(s&&this.hasExpired(s)){t.delete(r);continue}e.push(r)}return e.values()}get items(){let e=[];for(let t of this._store)for(let r of t.values()){if(this.hasExpired(r)){t.delete(r.key);continue}e.push(r)}return e.values()}get store(){return this._store}get(e){let t=this.getStore(e),r=t.get(e);if(r){if(r.expires&&Date.now()>r.expires){t.delete(e);return}return this.lruMoveToFront(e),this._useClone?this.clone(r.value):r.value}}getMany(e){let t=[];for(let r of e)t.push(this.get(r));return t}getRaw(e){let t=this.getStore(e),r=t.get(e);if(r){if(r.expires&&r.expires&&Date.now()>r.expires){t.delete(e);return}return this.lruMoveToFront(e),r}}getManyRaw(e){let t=[];for(let r of e)t.push(this.getRaw(r));return t}set(e,t,r){let s=this.getStore(e),d;if(r!==void 0||this._ttl!==void 0)if(typeof r=="object"){if(r.expire&&(d=typeof r.expire=="number"?r.expire:r.expire.getTime()),r.ttl){let n=(0,o.shorthandToTime)(r.ttl);n!==void 0&&(d=n)}}else{let n=(0,o.shorthandToTime)(r??this._ttl);n!==void 0&&(d=n)}if(this._lruSize>0){if(s.has(e))this.lruMoveToFront(e);else if(this.lruAddToFront(e),this._lru.size>this._lruSize){let n=this._lru.getOldest();n&&(this._lru.removeOldest(),this.delete(n))}}let v={key:e,value:t,expires:d};s.set(e,v)}setMany(e){for(let t of e)this.set(t.key,t.value,t.ttl)}has(e){return!!this.get(e)}hasMany(e){let t=[];for(let r of e){let s=this.get(r);t.push(!!s)}return t}take(e){let t=this.get(e);if(t)return this.delete(e),t}takeMany(e){let t=[];for(let r of e)t.push(this.take(r));return t}delete(e){this.getStore(e).delete(e)}deleteMany(e){for(let t of e)this.delete(t)}clear(){this._store=Array.from({length:this._storeHashSize},()=>new Map),this._lru=new h}getStore(e){let t=this.getKeyStoreHash(e);return this._store[t]||=new Map,this._store[t]}getKeyStoreHash(e){if(this._store.length===1)return 0;if(typeof this._storeHashAlgorithm=="function")return this._storeHashAlgorithm(e,this._storeHashSize);let t=this._storeHashSize-1;return(0,o.hashToNumber)(e,{min:0,max:t,algorithm:this._storeHashAlgorithm})}clone(e){return this.isPrimitive(e)?e:structuredClone(e)}lruAddToFront(e){this._lruSize!==0&&this._lru.addToFront(e)}lruMoveToFront(e){this._lruSize!==0&&this._lru.moveToFront(e)}lruResize(){for(;this._lru.size>this._lruSize;){let e=this._lru.getOldest();e&&(this._lru.removeOldest(),this.delete(e))}}checkExpiration(){for(let e of this._store)for(let t of e.values())t.expires&&Date.now()>t.expires&&e.delete(t.key)}startIntervalCheck(){this._checkInterval>0&&(this._interval&&clearInterval(this._interval),this._interval=setInterval(()=>{this.checkExpiration()},this._checkInterval).unref())}stopIntervalCheck(){this._interval&&clearInterval(this._interval),this._interval=0,this._checkInterval=0}wrap(e,t){let r={ttl:t?.ttl??this._ttl,keyPrefix:t?.keyPrefix,createKey:t?.createKey,cache:this};return(0,b.wrapSync)(e,r)}isPrimitive(e){return e==null||typeof e=="string"||typeof e=="number"||typeof e=="boolean"}setTtl(e){typeof e=="string"||e===void 0?this._ttl=e:e>0?this._ttl=e:this._ttl=void 0}hasExpired(e){return!!(e.expires&&Date.now()>e.expires)}};0&&(module.exports={CacheableMemory,HashAlgorithm,KeyvCacheableMemory,createKeyv,defaultStoreHashSize,hash,hashToNumber,maximumMapSize});
