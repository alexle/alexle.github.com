import{wrapSync as g}from"@cacheable/memoize";import{HashAlgorithm as b,hashToNumber as _,shorthandToTime as d}from"@cacheable/utils";import{Hookified as y}from"hookified";var c=class{value;prev=void 0;next=void 0;constructor(e){this.value=e}},o=class{head=void 0;tail=void 0;nodesMap=new Map;addToFront(e){let t=new c(e);this.head?(t.next=this.head,this.head.prev=t,this.head=t):this.head=this.tail=t,this.nodesMap.set(e,t)}moveToFront(e){let t=this.nodesMap.get(e);!t||this.head===t||(t.prev&&(t.prev.next=t.next),t.next&&(t.next.prev=t.prev),t===this.tail&&(this.tail=t.prev),t.prev=void 0,t.next=this.head,this.head&&(this.head.prev=t),this.head=t,this.tail??=t)}getOldest(){return this.tail?this.tail.value:void 0}removeOldest(){if(!this.tail)return;let e=this.tail.value;return this.tail.prev?(this.tail=this.tail.prev,this.tail.next=void 0):this.head=this.tail=void 0,this.nodesMap.delete(e),e}get size(){return this.nodesMap.size}};import{HashAlgorithm as k,hash as O,hashToNumber as K}from"@cacheable/utils";import{Keyv as m}from"keyv";var l=class{opts={ttl:0,useClone:!0,lruSize:0,checkInterval:0};_defaultCache=new a;_nCache=new Map;_namespace;constructor(e){e&&(this.opts=e,this._defaultCache=new a(e),e.namespace&&(this._namespace=e.namespace,this._nCache.set(this._namespace,new a(e))))}get namespace(){return this._namespace}set namespace(e){this._namespace=e}get store(){return this.getStore(this._namespace)}async get(e){let t=this.getStore(this._namespace).get(e);if(t)return t}async getMany(e){return this.getStore(this._namespace).getMany(e)}async set(e,t,r){this.getStore(this._namespace).set(e,t,r)}async setMany(e){this.getStore(this._namespace).setMany(e)}async delete(e){return this.getStore(this._namespace).delete(e),!0}async deleteMany(e){return this.getStore(this._namespace).deleteMany(e),!0}async clear(){this.getStore(this._namespace).clear()}async has(e){return this.getStore(this._namespace).has(e)}on(e,t){return this.getStore(this._namespace).on(e,t),this}getStore(e){return e?(this._nCache.has(e)||this._nCache.set(e,new a(this.opts)),this._nCache.get(e)):this._defaultCache}};function f(s){let e=new l(s),t=s?.namespace,r;s?.ttl&&Number.isInteger(s.ttl)&&(r=s?.ttl);let i=new m({store:e,namespace:t,ttl:r});return i.serialize=void 0,i.deserialize=void 0,i}var v=16,u=16777216,a=class extends y{_lru=new o;_storeHashSize=v;_storeHashAlgorithm=b.DJB2;_store=Array.from({length:this._storeHashSize},()=>new Map);_ttl;_useClone=!0;_lruSize=0;_checkInterval=0;_interval=0;constructor(e){super(),e?.ttl&&this.setTtl(e.ttl),e?.useClone!==void 0&&(this._useClone=e.useClone),e?.storeHashSize&&e.storeHashSize>0&&(this._storeHashSize=e.storeHashSize),e?.lruSize&&(e.lruSize>u?this.emit("error",new Error(`LRU size cannot be larger than ${u} due to Map limitations.`)):this._lruSize=e.lruSize),e?.checkInterval&&(this._checkInterval=e.checkInterval),e?.storeHashAlgorithm&&(this._storeHashAlgorithm=e.storeHashAlgorithm),this._store=Array.from({length:this._storeHashSize},()=>new Map),this.startIntervalCheck()}get ttl(){return this._ttl}set ttl(e){this.setTtl(e)}get useClone(){return this._useClone}set useClone(e){this._useClone=e}get lruSize(){return this._lruSize}set lruSize(e){if(e>u){this.emit("error",new Error(`LRU size cannot be larger than ${u} due to Map limitations.`));return}if(this._lruSize=e,this._lruSize===0){this._lru=new o;return}this.lruResize()}get checkInterval(){return this._checkInterval}set checkInterval(e){this._checkInterval=e}get size(){let e=0;for(let t of this._store)e+=t.size;return e}get storeHashSize(){return this._storeHashSize}set storeHashSize(e){e!==this._storeHashSize&&(this._storeHashSize=e,this._store=Array.from({length:this._storeHashSize},()=>new Map))}get storeHashAlgorithm(){return this._storeHashAlgorithm}set storeHashAlgorithm(e){this._storeHashAlgorithm=e}get keys(){let e=[];for(let t of this._store)for(let r of t.keys()){let i=t.get(r);if(i&&this.hasExpired(i)){t.delete(r);continue}e.push(r)}return e.values()}get items(){let e=[];for(let t of this._store)for(let r of t.values()){if(this.hasExpired(r)){t.delete(r.key);continue}e.push(r)}return e.values()}get store(){return this._store}get(e){let t=this.getStore(e),r=t.get(e);if(r){if(r.expires&&Date.now()>r.expires){t.delete(e);return}return this.lruMoveToFront(e),this._useClone?this.clone(r.value):r.value}}getMany(e){let t=[];for(let r of e)t.push(this.get(r));return t}getRaw(e){let t=this.getStore(e),r=t.get(e);if(r){if(r.expires&&r.expires&&Date.now()>r.expires){t.delete(e);return}return this.lruMoveToFront(e),r}}getManyRaw(e){let t=[];for(let r of e)t.push(this.getRaw(r));return t}set(e,t,r){let i=this.getStore(e),h;if(r!==void 0||this._ttl!==void 0)if(typeof r=="object"){if(r.expire&&(h=typeof r.expire=="number"?r.expire:r.expire.getTime()),r.ttl){let n=d(r.ttl);n!==void 0&&(h=n)}}else{let n=d(r??this._ttl);n!==void 0&&(h=n)}if(this._lruSize>0){if(i.has(e))this.lruMoveToFront(e);else if(this.lruAddToFront(e),this._lru.size>this._lruSize){let n=this._lru.getOldest();n&&(this._lru.removeOldest(),this.delete(n))}}let p={key:e,value:t,expires:h};i.set(e,p)}setMany(e){for(let t of e)this.set(t.key,t.value,t.ttl)}has(e){return!!this.get(e)}hasMany(e){let t=[];for(let r of e){let i=this.get(r);t.push(!!i)}return t}take(e){let t=this.get(e);if(t)return this.delete(e),t}takeMany(e){let t=[];for(let r of e)t.push(this.take(r));return t}delete(e){this.getStore(e).delete(e)}deleteMany(e){for(let t of e)this.delete(t)}clear(){this._store=Array.from({length:this._storeHashSize},()=>new Map),this._lru=new o}getStore(e){let t=this.getKeyStoreHash(e);return this._store[t]||=new Map,this._store[t]}getKeyStoreHash(e){if(this._store.length===1)return 0;if(typeof this._storeHashAlgorithm=="function")return this._storeHashAlgorithm(e,this._storeHashSize);let t=this._storeHashSize-1;return _(e,{min:0,max:t,algorithm:this._storeHashAlgorithm})}clone(e){return this.isPrimitive(e)?e:structuredClone(e)}lruAddToFront(e){this._lruSize!==0&&this._lru.addToFront(e)}lruMoveToFront(e){this._lruSize!==0&&this._lru.moveToFront(e)}lruResize(){for(;this._lru.size>this._lruSize;){let e=this._lru.getOldest();e&&(this._lru.removeOldest(),this.delete(e))}}checkExpiration(){for(let e of this._store)for(let t of e.values())t.expires&&Date.now()>t.expires&&e.delete(t.key)}startIntervalCheck(){this._checkInterval>0&&(this._interval&&clearInterval(this._interval),this._interval=setInterval(()=>{this.checkExpiration()},this._checkInterval).unref())}stopIntervalCheck(){this._interval&&clearInterval(this._interval),this._interval=0,this._checkInterval=0}wrap(e,t){let r={ttl:t?.ttl??this._ttl,keyPrefix:t?.keyPrefix,createKey:t?.createKey,cache:this};return g(e,r)}isPrimitive(e){return e==null||typeof e=="string"||typeof e=="number"||typeof e=="boolean"}setTtl(e){typeof e=="string"||e===void 0?this._ttl=e:e>0?this._ttl=e:this._ttl=void 0}hasExpired(e){return!!(e.expires&&Date.now()>e.expires)}};export{a as CacheableMemory,k as HashAlgorithm,l as KeyvCacheableMemory,f as createKeyv,v as defaultStoreHashSize,O as hash,K as hashToNumber,u as maximumMapSize};
