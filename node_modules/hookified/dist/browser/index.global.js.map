{"version":3,"sources":["../../src/eventified.ts","../../src/index.ts"],"sourcesContent":["// biome-ignore-all lint/suspicious/noExplicitAny: this is for event emitter compatibility\nimport type { Logger } from \"logger.js\";\n\nexport type IEventEmitter = {\n\t/**\n\t * Registers a listener for the specified event.\n\t *\n\t * @param eventName - The name (or symbol) of the event to listen for.\n\t * @param listener - A callback function that will be invoked when the event is emitted.\n\t * @returns The current instance of EventEmitter for method chaining.\n\t *\n\t * @example\n\t * emitter.on('data', (message) => {\n\t *   console.log(message);\n\t * });\n\t */\n\ton(\n\t\teventName: string | symbol,\n\t\tlistener: (...arguments_: any[]) => void,\n\t): IEventEmitter;\n\n\t/**\n\t * Alias for `on`. Registers a listener for the specified event.\n\t *\n\t * @param eventName - The name (or symbol) of the event to listen for.\n\t * @param listener - A callback function that will be invoked when the event is emitted.\n\t * @returns The current instance of EventEmitter for method chaining.\n\t */\n\taddListener(\n\t\teventName: string | symbol,\n\t\tlistener: (...arguments_: any[]) => void,\n\t): IEventEmitter;\n\n\t/**\n\t * Registers a one-time listener for the specified event. The listener is removed after it is called once.\n\t *\n\t * @param eventName - The name (or symbol) of the event to listen for.\n\t * @param listener - A callback function that will be invoked once when the event is emitted.\n\t * @returns The current instance of EventEmitter for method chaining.\n\t *\n\t * @example\n\t * emitter.once('close', () => {\n\t *   console.log('The connection was closed.');\n\t * });\n\t */\n\tonce(\n\t\teventName: string | symbol,\n\t\tlistener: (...arguments_: any[]) => void,\n\t): IEventEmitter;\n\n\t/**\n\t * Removes a previously registered listener for the specified event.\n\t *\n\t * @param eventName - The name (or symbol) of the event to stop listening for.\n\t * @param listener - The specific callback function to remove.\n\t * @returns The current instance of EventEmitter for method chaining.\n\t *\n\t * @example\n\t * emitter.off('data', myListener);\n\t */\n\toff(\n\t\teventName: string | symbol,\n\t\tlistener: (...arguments_: any[]) => void,\n\t): IEventEmitter;\n\n\t/**\n\t * Alias for `off`. Removes a previously registered listener for the specified event.\n\t *\n\t * @param eventName - The name (or symbol) of the event to stop listening for.\n\t * @param listener - The specific callback function to remove.\n\t * @returns The current instance of EventEmitter for method chaining.\n\t */\n\tremoveListener(\n\t\teventName: string | symbol,\n\t\tlistener: (...arguments_: any[]) => void,\n\t): IEventEmitter;\n\n\t/**\n\t * Emits the specified event, invoking all registered listeners with the provided arguments.\n\t *\n\t * @param eventName - The name (or symbol) of the event to emit.\n\t * @param args - Arguments passed to each listener.\n\t * @returns `true` if the event had listeners, `false` otherwise.\n\t *\n\t * @example\n\t * emitter.emit('data', 'Hello World');\n\t */\n\temit(eventName: string | symbol, ...arguments_: any[]): boolean;\n\n\t/**\n\t * Returns the number of listeners registered for the specified event.\n\t *\n\t * @param eventName - The name (or symbol) of the event.\n\t * @returns The number of registered listeners.\n\t *\n\t * @example\n\t * const count = emitter.listenerCount('data');\n\t * console.log(count); // e.g., 2\n\t */\n\tlistenerCount(eventName: string | symbol): number;\n\n\t/**\n\t * Removes all listeners for the specified event. If no event is specified, it removes all listeners for all events.\n\t *\n\t * @param eventName - (Optional) The name (or symbol) of the event.\n\t * @returns The current instance of EventEmitter for method chaining.\n\t *\n\t * @example\n\t * emitter.removeAllListeners('data');\n\t */\n\tremoveAllListeners(eventName?: string | symbol): IEventEmitter;\n\n\t/**\n\t * Returns an array of event names for which listeners have been registered.\n\t *\n\t * @returns An array of event names (or symbols).\n\t *\n\t * @example\n\t * const events = emitter.eventNames();\n\t * console.log(events); // e.g., ['data', 'close']\n\t */\n\teventNames(): Array<string | symbol>;\n\n\t/**\n\t * Returns an array of listeners registered for the specified event.\n\t *\n\t * @param eventName - The name (or symbol) of the event.\n\t * @returns An array of listener functions.\n\t *\n\t * @example\n\t * const listeners = emitter.listeners('data');\n\t * console.log(listeners.length); // e.g., 2\n\t */\n\tlisteners(eventName: string | symbol): Array<(...arguments_: any[]) => void>;\n\n\t/**\n\t * Returns an array of raw listeners for the specified event. This includes listeners wrapped by internal mechanisms (e.g., once-only listeners).\n\t *\n\t * @param eventName - The name (or symbol) of the event.\n\t * @returns An array of raw listener functions.\n\t *\n\t * @example\n\t * const rawListeners = emitter.rawListeners('data');\n\t */\n\trawListeners(\n\t\teventName: string | symbol,\n\t): Array<(...arguments_: any[]) => void>;\n\n\t/**\n\t * Adds a listener to the beginning of the listeners array for the specified event.\n\t *\n\t * @param eventName - The name (or symbol) of the event to listen for.\n\t * @param listener - A callback function that will be invoked when the event is emitted.\n\t * @returns The current instance of EventEmitter for method chaining.\n\t *\n\t * @example\n\t * emitter.prependListener('data', (message) => {\n\t *   console.log('This will run first.');\n\t * });\n\t */\n\tprependListener(\n\t\teventName: string | symbol,\n\t\tlistener: (...arguments_: any[]) => void,\n\t): IEventEmitter;\n\n\t/**\n\t * Adds a one-time listener to the beginning of the listeners array for the specified event.\n\t *\n\t * @param eventName - The name (or symbol) of the event to listen for.\n\t * @param listener - A callback function that will be invoked once when the event is emitted.\n\t * @returns The current instance of EventEmitter for method chaining.\n\t *\n\t * @example\n\t * emitter.prependOnceListener('data', (message) => {\n\t *   console.log('This will run first and only once.');\n\t * });\n\t */\n\tprependOnceListener(\n\t\teventName: string | symbol,\n\t\tlistener: (...arguments_: any[]) => void,\n\t): IEventEmitter;\n};\n\nexport type EventListener = (...arguments_: any[]) => void;\n\nexport type EventEmitterOptions = {\n\t/**\n\t * Logger instance for logging errors.\n\t */\n\tlogger?: Logger;\n\t/**\n\t * Whether to throw an error when emit 'error' and there are no listeners. Default is false and only emits an error event.\n\t */\n\tthrowOnEmitError?: boolean;\n};\n\nexport class Eventified implements IEventEmitter {\n\tprivate readonly _eventListeners: Map<string | symbol, EventListener[]>;\n\tprivate _maxListeners: number;\n\tprivate _logger?: Logger;\n\tprivate _throwOnEmitError = false;\n\n\tconstructor(options?: EventEmitterOptions) {\n\t\tthis._eventListeners = new Map<string | symbol, EventListener[]>();\n\t\tthis._maxListeners = 100; // Default maximum number of listeners\n\n\t\tthis._logger = options?.logger;\n\n\t\tif (options?.throwOnEmitError !== undefined) {\n\t\t\tthis._throwOnEmitError = options.throwOnEmitError;\n\t\t}\n\t}\n\n\t/**\n\t * Gets the logger\n\t * @returns {Logger}\n\t */\n\tpublic get logger(): Logger | undefined {\n\t\treturn this._logger;\n\t}\n\n\t/**\n\t * Sets the logger\n\t * @param {Logger} logger\n\t */\n\tpublic set logger(logger: Logger | undefined) {\n\t\tthis._logger = logger;\n\t}\n\n\t/**\n\t * Gets whether an error should be thrown when an emit throws an error. Default is false and only emits an error event.\n\t * @returns {boolean}\n\t */\n\tpublic get throwOnEmitError(): boolean {\n\t\treturn this._throwOnEmitError;\n\t}\n\n\t/**\n\t * Sets whether an error should be thrown when an emit throws an error. Default is false and only emits an error event.\n\t * @param {boolean} value\n\t */\n\tpublic set throwOnEmitError(value: boolean) {\n\t\tthis._throwOnEmitError = value;\n\t}\n\n\t/**\n\t * Adds a handler function for a specific event that will run only once\n\t * @param {string | symbol} eventName\n\t * @param {EventListener} listener\n\t * @returns {IEventEmitter} returns the instance of the class for chaining\n\t */\n\tpublic once(\n\t\teventName: string | symbol,\n\t\tlistener: EventListener,\n\t): IEventEmitter {\n\t\tconst onceListener: EventListener = (...arguments_: any[]) => {\n\t\t\tthis.off(eventName as string, onceListener);\n\t\t\tlistener(...arguments_);\n\t\t};\n\n\t\tthis.on(eventName as string, onceListener);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Gets the number of listeners for a specific event. If no event is provided, it returns the total number of listeners\n\t * @param {string} eventName The event name. Not required\n\t * @returns {number} The number of listeners\n\t */\n\tpublic listenerCount(eventName?: string | symbol): number {\n\t\tif (eventName === undefined) {\n\t\t\treturn this.getAllListeners().length;\n\t\t}\n\n\t\tconst listeners = this._eventListeners.get(eventName);\n\t\treturn listeners ? listeners.length : 0;\n\t}\n\n\t/**\n\t * Gets an array of event names\n\t * @returns {Array<string | symbol>} An array of event names\n\t */\n\tpublic eventNames(): Array<string | symbol> {\n\t\treturn [...this._eventListeners.keys()];\n\t}\n\n\t/**\n\t * Gets an array of listeners for a specific event. If no event is provided, it returns all listeners\n\t * @param {string} [event] (Optional) The event name\n\t * @returns {EventListener[]} An array of listeners\n\t */\n\tpublic rawListeners(event?: string | symbol): EventListener[] {\n\t\tif (event === undefined) {\n\t\t\treturn this.getAllListeners();\n\t\t}\n\n\t\treturn this._eventListeners.get(event) ?? [];\n\t}\n\n\t/**\n\t * Prepends a listener to the beginning of the listeners array for the specified event\n\t * @param {string | symbol} eventName\n\t * @param {EventListener} listener\n\t * @returns {IEventEmitter} returns the instance of the class for chaining\n\t */\n\tpublic prependListener(\n\t\teventName: string | symbol,\n\t\tlistener: EventListener,\n\t): IEventEmitter {\n\t\tconst listeners = this._eventListeners.get(eventName) ?? [];\n\t\tlisteners.unshift(listener);\n\t\tthis._eventListeners.set(eventName, listeners);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Prepends a one-time listener to the beginning of the listeners array for the specified event\n\t * @param {string | symbol} eventName\n\t * @param {EventListener} listener\n\t * @returns {IEventEmitter} returns the instance of the class for chaining\n\t */\n\tpublic prependOnceListener(\n\t\teventName: string | symbol,\n\t\tlistener: EventListener,\n\t): IEventEmitter {\n\t\tconst onceListener: EventListener = (...arguments_: any[]) => {\n\t\t\tthis.off(eventName as string, onceListener);\n\t\t\tlistener(...arguments_);\n\t\t};\n\n\t\tthis.prependListener(eventName as string, onceListener);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Gets the maximum number of listeners that can be added for a single event\n\t * @returns {number} The maximum number of listeners\n\t */\n\tpublic maxListeners(): number {\n\t\treturn this._maxListeners;\n\t}\n\n\t/**\n\t * Adds a listener for a specific event. It is an alias for the on() method\n\t * @param {string | symbol} event\n\t * @param {EventListener} listener\n\t * @returns {IEventEmitter} returns the instance of the class for chaining\n\t */\n\tpublic addListener(\n\t\tevent: string | symbol,\n\t\tlistener: EventListener,\n\t): IEventEmitter {\n\t\tthis.on(event, listener);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds a listener for a specific event\n\t * @param {string | symbol} event\n\t * @param {EventListener} listener\n\t * @returns {IEventEmitter} returns the instance of the class for chaining\n\t */\n\tpublic on(event: string | symbol, listener: EventListener): IEventEmitter {\n\t\tif (!this._eventListeners.has(event)) {\n\t\t\tthis._eventListeners.set(event, []);\n\t\t}\n\n\t\tconst listeners = this._eventListeners.get(event);\n\n\t\tif (listeners) {\n\t\t\tif (listeners.length >= this._maxListeners) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`MaxListenersExceededWarning: Possible event memory leak detected. ${listeners.length + 1} ${event as string} listeners added. Use setMaxListeners() to increase limit.`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tlisteners.push(listener);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes a listener for a specific event. It is an alias for the off() method\n\t * @param {string | symbol} event\n\t * @param {EventListener} listener\n\t * @returns {IEventEmitter} returns the instance of the class for chaining\n\t */\n\tpublic removeListener(event: string, listener: EventListener): IEventEmitter {\n\t\tthis.off(event, listener);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes a listener for a specific event\n\t * @param {string | symbol} event\n\t * @param {EventListener} listener\n\t * @returns {IEventEmitter} returns the instance of the class for chaining\n\t */\n\tpublic off(event: string | symbol, listener: EventListener): IEventEmitter {\n\t\tconst listeners = this._eventListeners.get(event) ?? [];\n\t\tconst index = listeners.indexOf(listener);\n\t\tif (index !== -1) {\n\t\t\tlisteners.splice(index, 1);\n\t\t}\n\n\t\tif (listeners.length === 0) {\n\t\t\tthis._eventListeners.delete(event);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calls all listeners for a specific event\n\t * @param {string | symbol} event\n\t * @param arguments_ The arguments to pass to the listeners\n\t * @returns {boolean} Returns true if the event had listeners, false otherwise\n\t */\n\tpublic emit(event: string | symbol, ...arguments_: any[]): boolean {\n\t\tlet result = false;\n\t\tconst listeners = this._eventListeners.get(event);\n\n\t\tif (listeners && listeners.length > 0) {\n\t\t\tfor (const listener of listeners) {\n\t\t\t\tlistener(...arguments_);\n\t\t\t\tresult = true;\n\t\t\t}\n\t\t}\n\n\t\tif (event === \"error\") {\n\t\t\tconst error =\n\t\t\t\targuments_[0] instanceof Error\n\t\t\t\t\t? arguments_[0]\n\t\t\t\t\t: new Error(`${arguments_[0]}`);\n\n\t\t\tif (this._throwOnEmitError && !result) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Gets all listeners for a specific event. If no event is provided, it returns all listeners\n\t * @param {string} [event] (Optional) The event name\n\t * @returns {EventListener[]} An array of listeners\n\t */\n\tpublic listeners(event: string | symbol): EventListener[] {\n\t\treturn this._eventListeners.get(event) ?? [];\n\t}\n\n\t/**\n\t * Removes all listeners for a specific event. If no event is provided, it removes all listeners\n\t * @param {string} [event] (Optional) The event name\n\t * @returns {IEventEmitter} returns the instance of the class for chaining\n\t */\n\tpublic removeAllListeners(event?: string | symbol): IEventEmitter {\n\t\tif (event !== undefined) {\n\t\t\tthis._eventListeners.delete(event);\n\t\t} else {\n\t\t\tthis._eventListeners.clear();\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the maximum number of listeners that can be added for a single event\n\t * @param {number} n The maximum number of listeners\n\t * @returns {void}\n\t */\n\tpublic setMaxListeners(n: number): void {\n\t\tthis._maxListeners = n;\n\t\tfor (const listeners of this._eventListeners.values()) {\n\t\t\tif (listeners.length > n) {\n\t\t\t\tlisteners.splice(n);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Gets all listeners\n\t * @returns {EventListener[]} An array of listeners\n\t */\n\tpublic getAllListeners(): EventListener[] {\n\t\tlet result: EventListener[] = [];\n\t\tfor (const listeners of this._eventListeners.values()) {\n\t\t\tresult = [...result, ...listeners];\n\t\t}\n\n\t\treturn result;\n\t}\n}\n","import { type EventEmitterOptions, Eventified } from \"./eventified.js\";\n\n// biome-ignore lint/suspicious/noExplicitAny: this is for any parameter compatibility\nexport type Hook = (...arguments_: any[]) => Promise<void> | void;\n\nexport type HookEntry = {\n\t/**\n\t * The event name for the hook\n\t */\n\tevent: string;\n\t/**\n\t * The handler function for the hook\n\t */\n\thandler: Hook;\n};\n\nexport type HookifiedOptions = {\n\t/**\n\t * Whether an error should be thrown when a hook throws an error. Default is false and only emits an error event.\n\t */\n\tthrowHookErrors?: boolean;\n\t/**\n\t * Whether to enforce that all hook names start with 'before' or 'after'. Default is false.\n\t * @type {boolean}\n\t * @default false\n\t */\n\tenforceBeforeAfter?: boolean;\n\t/**\n\t * Map of deprecated hook names to deprecation messages. When a deprecated hook is used, a warning will be emitted.\n\t * @type {Map<string, string>}\n\t * @default new Map()\n\t */\n\tdeprecatedHooks?: Map<string, string>;\n\t/**\n\t * Whether to allow deprecated hooks to be registered and executed. Default is true.\n\t * @type {boolean}\n\t * @default true\n\t */\n\tallowDeprecated?: boolean;\n} & EventEmitterOptions;\n\nexport class Hookified extends Eventified {\n\tprivate readonly _hooks: Map<string, Hook[]>;\n\tprivate _throwHookErrors = false;\n\tprivate _enforceBeforeAfter = false;\n\tprivate _deprecatedHooks: Map<string, string>;\n\tprivate _allowDeprecated = true;\n\n\tconstructor(options?: HookifiedOptions) {\n\t\tsuper({ logger: options?.logger });\n\t\tthis._hooks = new Map();\n\t\tthis._deprecatedHooks = options?.deprecatedHooks\n\t\t\t? new Map(options.deprecatedHooks)\n\t\t\t: new Map();\n\n\t\tif (options?.throwHookErrors !== undefined) {\n\t\t\tthis._throwHookErrors = options.throwHookErrors;\n\t\t}\n\n\t\tif (options?.enforceBeforeAfter !== undefined) {\n\t\t\tthis._enforceBeforeAfter = options.enforceBeforeAfter;\n\t\t}\n\n\t\tif (options?.allowDeprecated !== undefined) {\n\t\t\tthis._allowDeprecated = options.allowDeprecated;\n\t\t}\n\t}\n\n\t/**\n\t * Gets all hooks\n\t * @returns {Map<string, Hook[]>}\n\t */\n\tpublic get hooks() {\n\t\treturn this._hooks;\n\t}\n\n\t/**\n\t * Gets whether an error should be thrown when a hook throws an error. Default is false and only emits an error event.\n\t * @returns {boolean}\n\t */\n\tpublic get throwHookErrors() {\n\t\treturn this._throwHookErrors;\n\t}\n\n\t/**\n\t * Sets whether an error should be thrown when a hook throws an error. Default is false and only emits an error event.\n\t * @param {boolean} value\n\t */\n\tpublic set throwHookErrors(value) {\n\t\tthis._throwHookErrors = value;\n\t}\n\n\t/**\n\t * Gets whether to enforce that all hook names start with 'before' or 'after'. Default is false.\n\t * @returns {boolean}\n\t * @default false\n\t */\n\tpublic get enforceBeforeAfter() {\n\t\treturn this._enforceBeforeAfter;\n\t}\n\n\t/**\n\t * Sets whether to enforce that all hook names start with 'before' or 'after'. Default is false.\n\t * @param {boolean} value\n\t */\n\tpublic set enforceBeforeAfter(value) {\n\t\tthis._enforceBeforeAfter = value;\n\t}\n\n\t/**\n\t * Gets the map of deprecated hook names to deprecation messages.\n\t * @returns {Map<string, string>}\n\t */\n\tpublic get deprecatedHooks() {\n\t\treturn this._deprecatedHooks;\n\t}\n\n\t/**\n\t * Sets the map of deprecated hook names to deprecation messages.\n\t * @param {Map<string, string>} value\n\t */\n\tpublic set deprecatedHooks(value) {\n\t\tthis._deprecatedHooks = value;\n\t}\n\n\t/**\n\t * Gets whether deprecated hooks are allowed to be registered and executed. Default is true.\n\t * @returns {boolean}\n\t */\n\tpublic get allowDeprecated() {\n\t\treturn this._allowDeprecated;\n\t}\n\n\t/**\n\t * Sets whether deprecated hooks are allowed to be registered and executed. Default is true.\n\t * @param {boolean} value\n\t */\n\tpublic set allowDeprecated(value) {\n\t\tthis._allowDeprecated = value;\n\t}\n\n\t/**\n\t * Validates hook event name if enforceBeforeAfter is enabled\n\t * @param {string} event - The event name to validate\n\t * @throws {Error} If enforceBeforeAfter is true and event doesn't start with 'before' or 'after'\n\t */\n\tprivate validateHookName(event: string): void {\n\t\tif (this._enforceBeforeAfter) {\n\t\t\tconst eventValue = event.trim().toLocaleLowerCase();\n\t\t\tif (!eventValue.startsWith(\"before\") && !eventValue.startsWith(\"after\")) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Hook event \"${event}\" must start with \"before\" or \"after\" when enforceBeforeAfter is enabled`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if a hook is deprecated and emits a warning if it is\n\t * @param {string} event - The event name to check\n\t * @returns {boolean} - Returns true if the hook should proceed, false if it should be blocked\n\t */\n\tprivate checkDeprecatedHook(event: string): boolean {\n\t\tif (this._deprecatedHooks.has(event)) {\n\t\t\tconst message = this._deprecatedHooks.get(event);\n\t\t\tconst warningMessage = `Hook \"${event}\" is deprecated${message ? `: ${message}` : \"\"}`;\n\n\t\t\t// Emit deprecation warning event\n\t\t\tthis.emit(\"warn\", { hook: event, message: warningMessage });\n\n\t\t\t// Log to logger if available\n\t\t\tif (this.logger?.warn) {\n\t\t\t\tthis.logger.warn(warningMessage);\n\t\t\t}\n\n\t\t\t// Return false if deprecated hooks are not allowed\n\t\t\treturn this._allowDeprecated;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Adds a handler function for a specific event\n\t * @param {string} event\n\t * @param {Hook} handler - this can be async or sync\n\t * @returns {void}\n\t */\n\tpublic onHook(event: string, handler: Hook) {\n\t\tthis.validateHookName(event);\n\t\tif (!this.checkDeprecatedHook(event)) {\n\t\t\treturn; // Skip registration if deprecated hooks are not allowed\n\t\t}\n\t\tconst eventHandlers = this._hooks.get(event);\n\t\tif (eventHandlers) {\n\t\t\teventHandlers.push(handler);\n\t\t} else {\n\t\t\tthis._hooks.set(event, [handler]);\n\t\t}\n\t}\n\n\t/**\n\t * Adds a handler function for a specific event that runs before all other handlers\n\t * @param {HookEntry} hookEntry\n\t * @returns {void}\n\t */\n\tpublic onHookEntry(hookEntry: HookEntry) {\n\t\tthis.onHook(hookEntry.event, hookEntry.handler);\n\t}\n\n\t/**\n\t * Alias for onHook. This is provided for compatibility with other libraries that use the `addHook` method.\n\t * @param {string} event\n\t * @param {Hook} handler - this can be async or sync\n\t * @returns {void}\n\t */\n\tpublic addHook(event: string, handler: Hook) {\n\t\t// Alias for onHook\n\t\tthis.onHook(event, handler);\n\t}\n\n\t/**\n\t * Adds a handler function for a specific event\n\t * @param {Array<HookEntry>} hooks\n\t * @returns {void}\n\t */\n\tpublic onHooks(hooks: HookEntry[]) {\n\t\tfor (const hook of hooks) {\n\t\t\tthis.onHook(hook.event, hook.handler);\n\t\t}\n\t}\n\n\t/**\n\t * Adds a handler function for a specific event that runs before all other handlers\n\t * @param {string} event\n\t * @param {Hook} handler - this can be async or sync\n\t * @returns {void}\n\t */\n\tpublic prependHook(event: string, handler: Hook) {\n\t\tthis.validateHookName(event);\n\t\tif (!this.checkDeprecatedHook(event)) {\n\t\t\treturn; // Skip registration if deprecated hooks are not allowed\n\t\t}\n\t\tconst eventHandlers = this._hooks.get(event);\n\t\tif (eventHandlers) {\n\t\t\teventHandlers.unshift(handler);\n\t\t} else {\n\t\t\tthis._hooks.set(event, [handler]);\n\t\t}\n\t}\n\n\t/**\n\t * Adds a handler that only executes once for a specific event before all other handlers\n\t * @param event\n\t * @param handler\n\t */\n\tpublic prependOnceHook(event: string, handler: Hook) {\n\t\tthis.validateHookName(event);\n\t\tif (!this.checkDeprecatedHook(event)) {\n\t\t\treturn; // Skip registration if deprecated hooks are not allowed\n\t\t}\n\t\t// biome-ignore lint/suspicious/noExplicitAny: this is for any parameter compatibility\n\t\tconst hook = async (...arguments_: any[]) => {\n\t\t\tthis.removeHook(event, hook);\n\t\t\treturn handler(...arguments_);\n\t\t};\n\n\t\tthis.prependHook(event, hook);\n\t}\n\n\t/**\n\t * Adds a handler that only executes once for a specific event\n\t * @param event\n\t * @param handler\n\t */\n\tpublic onceHook(event: string, handler: Hook) {\n\t\tthis.validateHookName(event);\n\t\tif (!this.checkDeprecatedHook(event)) {\n\t\t\treturn; // Skip registration if deprecated hooks are not allowed\n\t\t}\n\t\t// biome-ignore lint/suspicious/noExplicitAny: this is for any parameter compatibility\n\t\tconst hook = async (...arguments_: any[]) => {\n\t\t\tthis.removeHook(event, hook);\n\t\t\treturn handler(...arguments_);\n\t\t};\n\n\t\tthis.onHook(event, hook);\n\t}\n\n\t/**\n\t * Removes a handler function for a specific event\n\t * @param {string} event\n\t * @param {Hook} handler\n\t * @returns {void}\n\t */\n\tpublic removeHook(event: string, handler: Hook) {\n\t\tthis.validateHookName(event);\n\t\tif (!this.checkDeprecatedHook(event)) {\n\t\t\treturn; // Skip removal if deprecated hooks are not allowed\n\t\t}\n\t\tconst eventHandlers = this._hooks.get(event);\n\t\tif (eventHandlers) {\n\t\t\tconst index = eventHandlers.indexOf(handler);\n\t\t\tif (index !== -1) {\n\t\t\t\teventHandlers.splice(index, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Removes all handlers for a specific event\n\t * @param {Array<HookEntry>} hooks\n\t * @returns {void}\n\t */\n\tpublic removeHooks(hooks: HookEntry[]) {\n\t\tfor (const hook of hooks) {\n\t\t\tthis.removeHook(hook.event, hook.handler);\n\t\t}\n\t}\n\n\t/**\n\t * Calls all handlers for a specific event\n\t * @param {string} event\n\t * @param {T[]} arguments_\n\t * @returns {Promise<void>}\n\t */\n\tpublic async hook<T>(event: string, ...arguments_: T[]) {\n\t\tthis.validateHookName(event);\n\t\tif (!this.checkDeprecatedHook(event)) {\n\t\t\treturn; // Skip execution if deprecated hooks are not allowed\n\t\t}\n\t\tconst eventHandlers = this._hooks.get(event);\n\t\tif (eventHandlers) {\n\t\t\tfor (const handler of eventHandlers) {\n\t\t\t\ttry {\n\t\t\t\t\tawait handler(...arguments_);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconst message = `${event}: ${(error as Error).message}`;\n\t\t\t\t\tthis.emit(\"error\", new Error(message));\n\t\t\t\t\tif (this.logger) {\n\t\t\t\t\t\tthis.logger.error(message);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this._throwHookErrors) {\n\t\t\t\t\t\tthrow new Error(message);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Prepends the word `before` to your hook. Example is event is `test`, the before hook is `before:test`.\n\t * @param {string} event - The event name\n\t * @param {T[]} arguments_ - The arguments to pass to the hook\n\t */\n\tpublic async beforeHook<T>(event: string, ...arguments_: T[]) {\n\t\tawait this.hook(`before:${event}`, ...arguments_);\n\t}\n\n\t/**\n\t * Prepends the word `after` to your hook. Example is event is `test`, the after hook is `after:test`.\n\t * @param {string} event - The event name\n\t * @param {T[]} arguments_ - The arguments to pass to the hook\n\t */\n\tpublic async afterHook<T>(event: string, ...arguments_: T[]) {\n\t\tawait this.hook(`after:${event}`, ...arguments_);\n\t}\n\n\t/**\n\t * Calls all handlers for a specific event. This is an alias for `hook` and is provided for\n\t * compatibility with other libraries that use the `callHook` method.\n\t * @param {string} event\n\t * @param {T[]} arguments_\n\t * @returns {Promise<void>}\n\t */\n\tpublic async callHook<T>(event: string, ...arguments_: T[]) {\n\t\tawait this.hook(event, ...arguments_);\n\t}\n\n\t/**\n\t * Gets all hooks for a specific event\n\t * @param {string} event\n\t * @returns {Hook[]}\n\t */\n\tpublic getHooks(event: string) {\n\t\tthis.validateHookName(event);\n\t\tif (!this.checkDeprecatedHook(event)) {\n\t\t\treturn undefined; // Return undefined if deprecated hooks are not allowed\n\t\t}\n\t\treturn this._hooks.get(event);\n\t}\n\n\t/**\n\t * Removes all hooks\n\t * @returns {void}\n\t */\n\tpublic clearHooks() {\n\t\tthis._hooks.clear();\n\t}\n}\n\nexport { Eventified, type EventListener } from \"./eventified.js\";\nexport type { Logger } from \"./logger.js\";\n"],"mappings":"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","names":["Eventified","options","__publicField","logger","value","eventName","listener","onceListener","arguments_","listeners","event","index","result","error","n","Hookified","Eventified","options","__publicField","value","event","eventValue","message","warningMessage","handler","eventHandlers","hookEntry","hooks","hook","arguments_","index","error"]}