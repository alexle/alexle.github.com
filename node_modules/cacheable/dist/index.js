import{getOrSet as I,wrap as K}from"@cacheable/memoize";import{createKeyv as F}from"@cacheable/memory";import{Stats as C,calculateTtlFromExpiration as p,getCascadingTtl as u,HashAlgorithm as S,hash as B,isKeyvInstance as v,shorthandToMilliseconds as T}from"@cacheable/utils";import{Hookified as P}from"hookified";import{Keyv as b}from"keyv";var f=(c=>(c.BEFORE_SET="BEFORE_SET",c.AFTER_SET="AFTER_SET",c.BEFORE_SET_MANY="BEFORE_SET_MANY",c.AFTER_SET_MANY="AFTER_SET_MANY",c.BEFORE_GET="BEFORE_GET",c.AFTER_GET="AFTER_GET",c.BEFORE_GET_MANY="BEFORE_GET_MANY",c.AFTER_GET_MANY="AFTER_GET_MANY",c.BEFORE_SECONDARY_SETS_PRIMARY="BEFORE_SECONDARY_SETS_PRIMARY",c))(f||{}),E=(e=>(e.ERROR="error",e.CACHE_HIT="cache:hit",e.CACHE_MISS="cache:miss",e))(E||{});import{Hookified as M}from"hookified";import{Qified as R}from"qified";var g=(e=>(e.ERROR="error",e.SET="cache:set",e.DELETE="cache:delete",e))(g||{}),d=class extends M{_qified=new R;constructor(t){super(t),this._qified=this.createQified(t.qified)}get qified(){return this._qified}set qified(t){this._qified=this.createQified(t)}async publish(t,s){await this._qified.publish(t,{id:crypto.randomUUID(),data:s})}subscribe(t,s){this._qified.subscribe("cache:set",{handler:async e=>{let i=e.data;i.cacheId!==s&&await t.set(i.key,i.value,i.ttl)}}),this._qified.subscribe("cache:delete",{handler:async e=>{let i=e.data;i.cacheId!==s&&await t.delete(i.key)}})}createQified(t){if(t instanceof R)return t;let s=Array.isArray(t)?t:[t];return new R({messageProviders:s})}};import{getOrSet as U,wrap as J,wrapSync as X}from"@cacheable/memoize";import{CacheableMemory as $,createKeyv as tt,KeyvCacheableMemory as et}from"@cacheable/memory";import{calculateTtlFromExpiration as it,getCascadingTtl as at,HashAlgorithm as nt,hash as rt,Stats as ct,shorthandToMilliseconds as ot,shorthandToTime as ht}from"@cacheable/utils";import{Keyv as yt,KeyvHooks as dt}from"keyv";var w=class extends P{_primary=F();_secondary;_nonBlocking=!1;_ttl;_stats=new C({enabled:!1});_namespace;_cacheId=Math.random().toString(36).slice(2);_sync;constructor(t){super(),t?.primary&&this.setPrimary(t.primary),t?.secondary&&this.setSecondary(t.secondary),t?.nonBlocking&&(this._nonBlocking=t.nonBlocking),t?.stats&&(this._stats.enabled=t.stats),t?.ttl&&this.setTtl(t.ttl),t?.cacheId&&(this._cacheId=t.cacheId),t?.namespace&&(this._namespace=t.namespace,this._primary.namespace=this.getNameSpace(),this._secondary&&(this._secondary.namespace=this.getNameSpace())),t?.sync&&(this._sync=t.sync instanceof d?t.sync:new d(t.sync),this._sync.subscribe(this._primary,this._cacheId))}get namespace(){return this._namespace}set namespace(t){this._namespace=t,this._primary.namespace=this.getNameSpace(),this._secondary&&(this._secondary.namespace=this.getNameSpace())}get stats(){return this._stats}get primary(){return this._primary}set primary(t){this._primary=t}get secondary(){return this._secondary}set secondary(t){this._secondary=t}get nonBlocking(){return this._nonBlocking}set nonBlocking(t){this._nonBlocking=t}get ttl(){return this._ttl}set ttl(t){this.setTtl(t)}get cacheId(){return this._cacheId}set cacheId(t){this._cacheId=t}get sync(){return this._sync}set sync(t){this._sync=t,this._sync&&this._sync.subscribe(this._primary,this._cacheId)}setPrimary(t){v(t)?this._primary=t:this._primary=new b(t),this._primary.on("error",s=>{this.emit("error",s)})}setSecondary(t){v(t)?this._secondary=t:this._secondary=new b(t),this._secondary.on("error",s=>{this.emit("error",s)})}getNameSpace(){return typeof this._namespace=="function"?this._namespace():this._namespace}async get(t,s){return(await this.getRaw(t,s))?.value}async getRaw(t,s){let e;try{await this.hook("BEFORE_GET",t),e=await this._primary.getRaw(t);let i;e?this.emit("cache:hit",{key:t,value:e.value,store:"primary"}):this.emit("cache:miss",{key:t,store:"primary"});let n=s?.nonBlocking??this._nonBlocking;if(!e&&this._secondary){let a;n?a=await this.processSecondaryForGetRawNonBlocking(this._primary,this._secondary,t):a=await this.processSecondaryForGetRaw(this._primary,this._secondary,t),a&&(e=a.result,i=a.ttl)}await this.hook("AFTER_GET",{key:t,result:e,ttl:i})}catch(i){this.emit("error",i)}return this.stats.enabled&&(e?this._stats.incrementHits():this._stats.incrementMisses(),this.stats.incrementGets()),e}async getManyRaw(t,s){let e=[];try{await this.hook("BEFORE_GET_MANY",t),e=await this._primary.getManyRaw(t);for(let[n,a]of t.entries())e[n]?this.emit("cache:hit",{key:a,value:e[n].value,store:"primary"}):this.emit("cache:miss",{key:a,store:"primary"});let i=s?.nonBlocking??this._nonBlocking;this._secondary&&(i?await this.processSecondaryForGetManyRawNonBlocking(this._primary,this._secondary,t,e):await this.processSecondaryForGetManyRaw(this._primary,this._secondary,t,e)),await this.hook("AFTER_GET_MANY",{keys:t,result:e})}catch(i){this.emit("error",i)}if(this.stats.enabled){for(let i of e)i?this._stats.incrementHits():this._stats.incrementMisses();this.stats.incrementGets()}return e}async getMany(t,s){return(await this.getManyRaw(t,s)).map(i=>i?.value)}async set(t,s,e){let i=!1,n=T(e??this._ttl);try{let a={key:t,value:s,ttl:n};await this.hook("BEFORE_SET",a);let r=[];if(r.push(this._primary.set(a.key,a.value,a.ttl)),this._secondary&&r.push(this._secondary.set(a.key,a.value,a.ttl)),this._nonBlocking){i=await Promise.race(r);for(let o of r)o.catch(c=>{this.emit("error",c)})}else i=(await Promise.all(r))[0];await this.hook("AFTER_SET",a),this._sync&&i&&await this._sync.publish("cache:set",{cacheId:this._cacheId,key:a.key,value:a.value,ttl:a.ttl})}catch(a){this.emit("error",a)}return this.stats.enabled&&(this.stats.incrementKSize(t),this.stats.incrementCount(),this.stats.incrementVSize(s),this.stats.incrementSets()),i}async setMany(t){let s=!1;try{if(await this.hook("BEFORE_SET_MANY",t),s=await this.setManyKeyv(this._primary,t),this._secondary&&(this._nonBlocking?this.setManyKeyv(this._secondary,t).catch(e=>{this.emit("error",e)}):await this.setManyKeyv(this._secondary,t)),await this.hook("AFTER_SET_MANY",t),this._sync&&s)for(let e of t)await this._sync.publish("cache:set",{cacheId:this._cacheId,key:e.key,value:e.value,ttl:T(e.ttl)})}catch(e){this.emit("error",e)}if(this.stats.enabled)for(let e of t)this.stats.incrementKSize(e.key),this.stats.incrementCount(),this.stats.incrementVSize(e.value);return s}async take(t){let s=await this.get(t);return await this.delete(t),s}async takeMany(t){let s=await this.getMany(t);return await this.deleteMany(t),s}async has(t){let s=[];s.push(this._primary.has(t)),this._secondary&&s.push(this._secondary.has(t));let e=await Promise.all(s);for(let i of e)if(i)return!0;return!1}async hasMany(t){let s=await this.hasManyKeyv(this._primary,t),e=[];for(let[i,n]of t.entries())!s[i]&&this._secondary&&e.push(n);if(e.length>0&&this._secondary){let i=await this.hasManyKeyv(this._secondary,t);for(let[n,a]of t.entries())!s[n]&&i[n]&&(s[n]=i[n])}return s}async delete(t){let s=!1,e=[];if(this.stats.enabled){let i=await this._primary.get(t);i&&(this.stats.decreaseKSize(t),this.stats.decreaseVSize(i),this.stats.decreaseCount(),this.stats.incrementDeletes())}if(e.push(this._primary.delete(t)),this._secondary&&e.push(this._secondary.delete(t)),this.nonBlocking){s=await Promise.race(e);for(let i of e)i.catch(n=>{this.emit("error",n)})}else s=(await Promise.all(e))[0];return this._sync&&s&&await this._sync.publish("cache:delete",{cacheId:this._cacheId,key:t}),s}async deleteMany(t){if(this.stats.enabled){let e=await this._primary.get(t);for(let i of t)this.stats.decreaseKSize(i),this.stats.decreaseVSize(e),this.stats.decreaseCount(),this.stats.incrementDeletes()}let s=await this._primary.deleteMany(t);if(this._secondary&&(this._nonBlocking?this._secondary.deleteMany(t).catch(e=>{this.emit("error",e)}):await this._secondary.deleteMany(t)),this._sync&&s)for(let e of t)await this._sync.publish("cache:delete",{cacheId:this._cacheId,key:e});return s}async clear(){let t=[];t.push(this._primary.clear()),this._secondary&&t.push(this._secondary.clear()),await(this._nonBlocking?Promise.race(t):Promise.all(t)),this.stats.enabled&&(this._stats.resetStoreValues(),this._stats.incrementClears())}async disconnect(){let t=[];t.push(this._primary.disconnect()),this._secondary&&t.push(this._secondary.disconnect()),await(this._nonBlocking?Promise.race(t):Promise.all(t))}wrap(t,s){let e={get:async n=>this.get(n),has:async n=>this.has(n),set:async(n,a,r)=>{await this.set(n,a,r)},on:(n,a)=>{this.on(n,a)},emit:(n,...a)=>this.emit(n,...a)},i={ttl:s?.ttl??this._ttl,keyPrefix:s?.keyPrefix,createKey:s?.createKey,cacheErrors:s?.cacheErrors,cache:e,cacheId:this._cacheId,serialize:s?.serialize};return K(t,i)}async getOrSet(t,s,e){let n={cache:{get:async a=>this.get(a),has:async a=>this.has(a),set:async(a,r,o)=>{await this.set(a,r,o)},on:(a,r)=>{this.on(a,r)},emit:(a,...r)=>this.emit(a,...r)},cacheId:this._cacheId,ttl:e?.ttl??this._ttl,cacheErrors:e?.cacheErrors,throwErrors:e?.throwErrors};return I(t,s,n)}hash(t,s=S.SHA256){let e=Object.values(S).includes(s)?s:S.SHA256;return B(t,{algorithm:e})}async setManyKeyv(t,s){let e=[];for(let i of s){let n=T(i.ttl??this._ttl);e.push({key:i.key,value:i.value,ttl:n})}return await t.setMany(e),!0}async hasManyKeyv(t,s){let e=[];for(let i of s)e.push(t.has(i));return Promise.all(e)}async processSecondaryForGetRaw(t,s,e){let i=await s.getRaw(e);if(i?.value){this.emit("cache:hit",{key:e,value:i.value,store:"secondary"});let n=u(this._ttl,this._primary.ttl),a=i.expires??void 0,r=p(n,a),o={key:e,value:i.value,ttl:r};return await this.hook("BEFORE_SECONDARY_SETS_PRIMARY",o),await t.set(o.key,o.value,o.ttl),{result:i,ttl:r}}else{this.emit("cache:miss",{key:e,store:"secondary"});return}}async processSecondaryForGetRawNonBlocking(t,s,e){let i=await s.getRaw(e);if(i?.value){this.emit("cache:hit",{key:e,value:i.value,store:"secondary"});let n=u(this._ttl,this._primary.ttl),a=i.expires??void 0,r=p(n,a),o={key:e,value:i.value,ttl:r};return this.hook("BEFORE_SECONDARY_SETS_PRIMARY",o).then(async()=>{await t.set(o.key,o.value,o.ttl)}).catch(c=>{this.emit("error",c)}),{result:i,ttl:r}}else{this.emit("cache:miss",{key:e,store:"secondary"});return}}async processSecondaryForGetManyRaw(t,s,e,i){let n=[];for(let[o,c]of e.entries())i[o]||n.push(c);let a=await s.getManyRaw(n),r=0;for await(let[o,c]of e.entries())if(!i[o]){let h=a[r];if(h&&h.value!==void 0){i[o]=h,this.emit("cache:hit",{key:c,value:h.value,store:"secondary"});let _=u(this._ttl,this._primary.ttl),{expires:y}=h;y===null&&(y=void 0);let m=p(_,y),l={key:c,value:h.value,ttl:m};await this.hook("BEFORE_SECONDARY_SETS_PRIMARY",l),await t.set(l.key,l.value,l.ttl)}else this.emit("cache:miss",{key:c,store:"secondary"});r++}}async processSecondaryForGetManyRawNonBlocking(t,s,e,i){let n=[];for(let[o,c]of e.entries())i[o]||n.push(c);let a=await s.getManyRaw(n),r=0;for await(let[o,c]of e.entries())if(!i[o]){let h=a[r];if(h&&h.value!==void 0){i[o]=h,this.emit("cache:hit",{key:c,value:h.value,store:"secondary"});let _=u(this._ttl,this._primary.ttl),{expires:y}=h;y===null&&(y=void 0);let m=p(_,y),l={key:c,value:h.value,ttl:m};this.hook("BEFORE_SECONDARY_SETS_PRIMARY",l).then(async()=>{await t.set(l.key,l.value,l.ttl)}).catch(O=>{this.emit("error",O)})}else this.emit("cache:miss",{key:c,store:"secondary"});r++}}setTtl(t){typeof t=="string"||t===void 0?this._ttl=t:t>0?this._ttl=t:this._ttl=void 0}};export{w as Cacheable,E as CacheableEvents,f as CacheableHooks,$ as CacheableMemory,ct as CacheableStats,d as CacheableSync,g as CacheableSyncEvents,nt as HashAlgorithm,yt as Keyv,et as KeyvCacheableMemory,dt as KeyvHooks,it as calculateTtlFromExpiration,tt as createKeyv,at as getCascadingTtl,U as getOrSet,rt as hash,ot as shorthandToMilliseconds,ht as shorthandToTime,J as wrap,X as wrapSync};
