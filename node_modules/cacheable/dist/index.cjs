"use strict";var A=Object.defineProperty;var B=Object.getOwnPropertyDescriptor;var P=Object.getOwnPropertyNames;var G=Object.prototype.hasOwnProperty;var k=(d,t)=>{for(var i in t)A(d,i,{get:t[i],enumerable:!0})},x=(d,t,i,e)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of P(t))!G.call(d,s)&&s!==i&&A(d,s,{get:()=>t[s],enumerable:!(e=B(t,s))||e.enumerable});return d};var N=d=>x(A({},"__esModule",{value:!0}),d);var Y={};k(Y,{Cacheable:()=>M,CacheableEvents:()=>R,CacheableHooks:()=>E,CacheableMemory:()=>f.CacheableMemory,CacheableStats:()=>l.Stats,CacheableSync:()=>_,CacheableSyncEvents:()=>S,HashAlgorithm:()=>l.HashAlgorithm,Keyv:()=>v.Keyv,KeyvCacheableMemory:()=>f.KeyvCacheableMemory,KeyvHooks:()=>v.KeyvHooks,calculateTtlFromExpiration:()=>l.calculateTtlFromExpiration,createKeyv:()=>f.createKeyv,getCascadingTtl:()=>l.getCascadingTtl,getOrSet:()=>m.getOrSet,hash:()=>l.hash,shorthandToMilliseconds:()=>l.shorthandToMilliseconds,shorthandToTime:()=>l.shorthandToTime,wrap:()=>m.wrap,wrapSync:()=>m.wrapSync});module.exports=N(Y);var T=require("@cacheable/memoize"),K=require("@cacheable/memory"),o=require("@cacheable/utils"),F=require("hookified"),O=require("keyv");var E=(c=>(c.BEFORE_SET="BEFORE_SET",c.AFTER_SET="AFTER_SET",c.BEFORE_SET_MANY="BEFORE_SET_MANY",c.AFTER_SET_MANY="AFTER_SET_MANY",c.BEFORE_GET="BEFORE_GET",c.AFTER_GET="AFTER_GET",c.BEFORE_GET_MANY="BEFORE_GET_MANY",c.AFTER_GET_MANY="AFTER_GET_MANY",c.BEFORE_SECONDARY_SETS_PRIMARY="BEFORE_SECONDARY_SETS_PRIMARY",c))(E||{}),R=(e=>(e.ERROR="error",e.CACHE_HIT="cache:hit",e.CACHE_MISS="cache:miss",e))(R||{});var I=require("hookified"),g=require("qified"),S=(e=>(e.ERROR="error",e.SET="cache:set",e.DELETE="cache:delete",e))(S||{}),_=class extends I.Hookified{_qified=new g.Qified;constructor(t){super(t),this._qified=this.createQified(t.qified)}get qified(){return this._qified}set qified(t){this._qified=this.createQified(t)}async publish(t,i){await this._qified.publish(t,{id:crypto.randomUUID(),data:i})}subscribe(t,i){this._qified.subscribe("cache:set",{handler:async e=>{let s=e.data;s.cacheId!==i&&await t.set(s.key,s.value,s.ttl)}}),this._qified.subscribe("cache:delete",{handler:async e=>{let s=e.data;s.cacheId!==i&&await t.delete(s.key)}})}createQified(t){if(t instanceof g.Qified)return t;let i=Array.isArray(t)?t:[t];return new g.Qified({messageProviders:i})}};var m=require("@cacheable/memoize"),f=require("@cacheable/memory"),l=require("@cacheable/utils"),v=require("keyv"),M=class extends F.Hookified{_primary=(0,K.createKeyv)();_secondary;_nonBlocking=!1;_ttl;_stats=new o.Stats({enabled:!1});_namespace;_cacheId=Math.random().toString(36).slice(2);_sync;constructor(t){super(),t?.primary&&this.setPrimary(t.primary),t?.secondary&&this.setSecondary(t.secondary),t?.nonBlocking&&(this._nonBlocking=t.nonBlocking),t?.stats&&(this._stats.enabled=t.stats),t?.ttl&&this.setTtl(t.ttl),t?.cacheId&&(this._cacheId=t.cacheId),t?.namespace&&(this._namespace=t.namespace,this._primary.namespace=this.getNameSpace(),this._secondary&&(this._secondary.namespace=this.getNameSpace())),t?.sync&&(this._sync=t.sync instanceof _?t.sync:new _(t.sync),this._sync.subscribe(this._primary,this._cacheId))}get namespace(){return this._namespace}set namespace(t){this._namespace=t,this._primary.namespace=this.getNameSpace(),this._secondary&&(this._secondary.namespace=this.getNameSpace())}get stats(){return this._stats}get primary(){return this._primary}set primary(t){this._primary=t}get secondary(){return this._secondary}set secondary(t){this._secondary=t}get nonBlocking(){return this._nonBlocking}set nonBlocking(t){this._nonBlocking=t}get ttl(){return this._ttl}set ttl(t){this.setTtl(t)}get cacheId(){return this._cacheId}set cacheId(t){this._cacheId=t}get sync(){return this._sync}set sync(t){this._sync=t,this._sync&&this._sync.subscribe(this._primary,this._cacheId)}setPrimary(t){(0,o.isKeyvInstance)(t)?this._primary=t:this._primary=new O.Keyv(t),this._primary.on("error",i=>{this.emit("error",i)})}setSecondary(t){(0,o.isKeyvInstance)(t)?this._secondary=t:this._secondary=new O.Keyv(t),this._secondary.on("error",i=>{this.emit("error",i)})}getNameSpace(){return typeof this._namespace=="function"?this._namespace():this._namespace}async get(t,i){return(await this.getRaw(t,i))?.value}async getRaw(t,i){let e;try{await this.hook("BEFORE_GET",t),e=await this._primary.getRaw(t);let s;e?this.emit("cache:hit",{key:t,value:e.value,store:"primary"}):this.emit("cache:miss",{key:t,store:"primary"});let n=i?.nonBlocking??this._nonBlocking;if(!e&&this._secondary){let a;n?a=await this.processSecondaryForGetRawNonBlocking(this._primary,this._secondary,t):a=await this.processSecondaryForGetRaw(this._primary,this._secondary,t),a&&(e=a.result,s=a.ttl)}await this.hook("AFTER_GET",{key:t,result:e,ttl:s})}catch(s){this.emit("error",s)}return this.stats.enabled&&(e?this._stats.incrementHits():this._stats.incrementMisses(),this.stats.incrementGets()),e}async getManyRaw(t,i){let e=[];try{await this.hook("BEFORE_GET_MANY",t),e=await this._primary.getManyRaw(t);for(let[n,a]of t.entries())e[n]?this.emit("cache:hit",{key:a,value:e[n].value,store:"primary"}):this.emit("cache:miss",{key:a,store:"primary"});let s=i?.nonBlocking??this._nonBlocking;this._secondary&&(s?await this.processSecondaryForGetManyRawNonBlocking(this._primary,this._secondary,t,e):await this.processSecondaryForGetManyRaw(this._primary,this._secondary,t,e)),await this.hook("AFTER_GET_MANY",{keys:t,result:e})}catch(s){this.emit("error",s)}if(this.stats.enabled){for(let s of e)s?this._stats.incrementHits():this._stats.incrementMisses();this.stats.incrementGets()}return e}async getMany(t,i){return(await this.getManyRaw(t,i)).map(s=>s?.value)}async set(t,i,e){let s=!1,n=(0,o.shorthandToMilliseconds)(e??this._ttl);try{let a={key:t,value:i,ttl:n};await this.hook("BEFORE_SET",a);let r=[];if(r.push(this._primary.set(a.key,a.value,a.ttl)),this._secondary&&r.push(this._secondary.set(a.key,a.value,a.ttl)),this._nonBlocking){s=await Promise.race(r);for(let h of r)h.catch(c=>{this.emit("error",c)})}else s=(await Promise.all(r))[0];await this.hook("AFTER_SET",a),this._sync&&s&&await this._sync.publish("cache:set",{cacheId:this._cacheId,key:a.key,value:a.value,ttl:a.ttl})}catch(a){this.emit("error",a)}return this.stats.enabled&&(this.stats.incrementKSize(t),this.stats.incrementCount(),this.stats.incrementVSize(i),this.stats.incrementSets()),s}async setMany(t){let i=!1;try{if(await this.hook("BEFORE_SET_MANY",t),i=await this.setManyKeyv(this._primary,t),this._secondary&&(this._nonBlocking?this.setManyKeyv(this._secondary,t).catch(e=>{this.emit("error",e)}):await this.setManyKeyv(this._secondary,t)),await this.hook("AFTER_SET_MANY",t),this._sync&&i)for(let e of t)await this._sync.publish("cache:set",{cacheId:this._cacheId,key:e.key,value:e.value,ttl:(0,o.shorthandToMilliseconds)(e.ttl)})}catch(e){this.emit("error",e)}if(this.stats.enabled)for(let e of t)this.stats.incrementKSize(e.key),this.stats.incrementCount(),this.stats.incrementVSize(e.value);return i}async take(t){let i=await this.get(t);return await this.delete(t),i}async takeMany(t){let i=await this.getMany(t);return await this.deleteMany(t),i}async has(t){let i=[];i.push(this._primary.has(t)),this._secondary&&i.push(this._secondary.has(t));let e=await Promise.all(i);for(let s of e)if(s)return!0;return!1}async hasMany(t){let i=await this.hasManyKeyv(this._primary,t),e=[];for(let[s,n]of t.entries())!i[s]&&this._secondary&&e.push(n);if(e.length>0&&this._secondary){let s=await this.hasManyKeyv(this._secondary,t);for(let[n,a]of t.entries())!i[n]&&s[n]&&(i[n]=s[n])}return i}async delete(t){let i=!1,e=[];if(this.stats.enabled){let s=await this._primary.get(t);s&&(this.stats.decreaseKSize(t),this.stats.decreaseVSize(s),this.stats.decreaseCount(),this.stats.incrementDeletes())}if(e.push(this._primary.delete(t)),this._secondary&&e.push(this._secondary.delete(t)),this.nonBlocking){i=await Promise.race(e);for(let s of e)s.catch(n=>{this.emit("error",n)})}else i=(await Promise.all(e))[0];return this._sync&&i&&await this._sync.publish("cache:delete",{cacheId:this._cacheId,key:t}),i}async deleteMany(t){if(this.stats.enabled){let e=await this._primary.get(t);for(let s of t)this.stats.decreaseKSize(s),this.stats.decreaseVSize(e),this.stats.decreaseCount(),this.stats.incrementDeletes()}let i=await this._primary.deleteMany(t);if(this._secondary&&(this._nonBlocking?this._secondary.deleteMany(t).catch(e=>{this.emit("error",e)}):await this._secondary.deleteMany(t)),this._sync&&i)for(let e of t)await this._sync.publish("cache:delete",{cacheId:this._cacheId,key:e});return i}async clear(){let t=[];t.push(this._primary.clear()),this._secondary&&t.push(this._secondary.clear()),await(this._nonBlocking?Promise.race(t):Promise.all(t)),this.stats.enabled&&(this._stats.resetStoreValues(),this._stats.incrementClears())}async disconnect(){let t=[];t.push(this._primary.disconnect()),this._secondary&&t.push(this._secondary.disconnect()),await(this._nonBlocking?Promise.race(t):Promise.all(t))}wrap(t,i){let e={get:async n=>this.get(n),has:async n=>this.has(n),set:async(n,a,r)=>{await this.set(n,a,r)},on:(n,a)=>{this.on(n,a)},emit:(n,...a)=>this.emit(n,...a)},s={ttl:i?.ttl??this._ttl,keyPrefix:i?.keyPrefix,createKey:i?.createKey,cacheErrors:i?.cacheErrors,cache:e,cacheId:this._cacheId,serialize:i?.serialize};return(0,T.wrap)(t,s)}async getOrSet(t,i,e){let n={cache:{get:async a=>this.get(a),has:async a=>this.has(a),set:async(a,r,h)=>{await this.set(a,r,h)},on:(a,r)=>{this.on(a,r)},emit:(a,...r)=>this.emit(a,...r)},cacheId:this._cacheId,ttl:e?.ttl??this._ttl,cacheErrors:e?.cacheErrors,throwErrors:e?.throwErrors};return(0,T.getOrSet)(t,i,n)}hash(t,i=o.HashAlgorithm.SHA256){let e=Object.values(o.HashAlgorithm).includes(i)?i:o.HashAlgorithm.SHA256;return(0,o.hash)(t,{algorithm:e})}async setManyKeyv(t,i){let e=[];for(let s of i){let n=(0,o.shorthandToMilliseconds)(s.ttl??this._ttl);e.push({key:s.key,value:s.value,ttl:n})}return await t.setMany(e),!0}async hasManyKeyv(t,i){let e=[];for(let s of i)e.push(t.has(s));return Promise.all(e)}async processSecondaryForGetRaw(t,i,e){let s=await i.getRaw(e);if(s?.value){this.emit("cache:hit",{key:e,value:s.value,store:"secondary"});let n=(0,o.getCascadingTtl)(this._ttl,this._primary.ttl),a=s.expires??void 0,r=(0,o.calculateTtlFromExpiration)(n,a),h={key:e,value:s.value,ttl:r};return await this.hook("BEFORE_SECONDARY_SETS_PRIMARY",h),await t.set(h.key,h.value,h.ttl),{result:s,ttl:r}}else{this.emit("cache:miss",{key:e,store:"secondary"});return}}async processSecondaryForGetRawNonBlocking(t,i,e){let s=await i.getRaw(e);if(s?.value){this.emit("cache:hit",{key:e,value:s.value,store:"secondary"});let n=(0,o.getCascadingTtl)(this._ttl,this._primary.ttl),a=s.expires??void 0,r=(0,o.calculateTtlFromExpiration)(n,a),h={key:e,value:s.value,ttl:r};return this.hook("BEFORE_SECONDARY_SETS_PRIMARY",h).then(async()=>{await t.set(h.key,h.value,h.ttl)}).catch(c=>{this.emit("error",c)}),{result:s,ttl:r}}else{this.emit("cache:miss",{key:e,store:"secondary"});return}}async processSecondaryForGetManyRaw(t,i,e,s){let n=[];for(let[h,c]of e.entries())s[h]||n.push(c);let a=await i.getManyRaw(n),r=0;for await(let[h,c]of e.entries())if(!s[h]){let y=a[r];if(y&&y.value!==void 0){s[h]=y,this.emit("cache:hit",{key:c,value:y.value,store:"secondary"});let b=(0,o.getCascadingTtl)(this._ttl,this._primary.ttl),{expires:u}=y;u===null&&(u=void 0);let w=(0,o.calculateTtlFromExpiration)(b,u),p={key:c,value:y.value,ttl:w};await this.hook("BEFORE_SECONDARY_SETS_PRIMARY",p),await t.set(p.key,p.value,p.ttl)}else this.emit("cache:miss",{key:c,store:"secondary"});r++}}async processSecondaryForGetManyRawNonBlocking(t,i,e,s){let n=[];for(let[h,c]of e.entries())s[h]||n.push(c);let a=await i.getManyRaw(n),r=0;for await(let[h,c]of e.entries())if(!s[h]){let y=a[r];if(y&&y.value!==void 0){s[h]=y,this.emit("cache:hit",{key:c,value:y.value,store:"secondary"});let b=(0,o.getCascadingTtl)(this._ttl,this._primary.ttl),{expires:u}=y;u===null&&(u=void 0);let w=(0,o.calculateTtlFromExpiration)(b,u),p={key:c,value:y.value,ttl:w};this.hook("BEFORE_SECONDARY_SETS_PRIMARY",p).then(async()=>{await t.set(p.key,p.value,p.ttl)}).catch(C=>{this.emit("error",C)})}else this.emit("cache:miss",{key:c,store:"secondary"});r++}}setTtl(t){typeof t=="string"||t===void 0?this._ttl=t:t>0?this._ttl=t:this._ttl=void 0}};0&&(module.exports={Cacheable,CacheableEvents,CacheableHooks,CacheableMemory,CacheableStats,CacheableSync,CacheableSyncEvents,HashAlgorithm,Keyv,KeyvCacheableMemory,KeyvHooks,calculateTtlFromExpiration,createKeyv,getCascadingTtl,getOrSet,hash,shorthandToMilliseconds,shorthandToTime,wrap,wrapSync});
