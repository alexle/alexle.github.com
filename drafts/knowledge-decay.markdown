


Don’t lose the questions. Don’t lose the curiosity. Even after pursuit of it rewards you with knowledge. Never be so knowledgeable that you lose naive optimism that new discoveries are around the corner.

Knowledge is cheap, curiosity is priceless

Google has made factual knowledge all but useless. Remember when you had to call your music obsessed friend to settle a fight over what year a song debuted? Knowledge has never been less valuable, which in turn has made penetrating curiosity and ability to ask the best questions more valuable than ever.

But it’s not just about the internet. Knowledge has always been less valuable than curiosity. Henry Ford didn’t know how to do almost any specific operation in his business, but he could let his questions drive him to find those who could. Einstein was famously ignorant several of basic facts, because he wanted to free his mind up for the higher level work of questioning and

The curious employee > the knowledgeable one

I’ve hired curious people and I’ve hired knowledgeable people. The latter are generally less fun to work with and have a much lower ceiling, even if they can do their specific task well. The former are a font of delightful surprises. They make me better because they ask questions I hadn’t thought of. They excite me, because every waking hour I know that not only are they doing their job, they are exploring and probing and chasing their curiosity all kinds of places and will bring back cool new ideas that benefit the company.



Do you work in software? Do you have more than a decade of experience? You do? I’m sorry to hear that. That means there’s a strong possibility that much of what you know is already obsolete. Worse yet, there’s a good chance that you’re set in anachronistic ways, hidebound with habits which are now considered harmful. If you think your experience is automatically valuable, I warn you: think again.

To be clear, I am not arguing in favor of age discrimination, which is wrong, illegal, and stupid. (Some of the finest engineers I’ve ever known, who anyone would be happy to hire in a heartbeat, are in their 50s.) I am, however, arguing that tech’s ever-accelerating pace of change means that people tend to greatly overestimate the value of their experience, the returns from which diminish every year.

Whether you’re a developer, DevOps, or a manager, you never get to stop having to constantly prove yourself. That is the nature of the tech beast.

The most important skill, one that truly doesn’t get old, is the meta-skill of constantly learning new things … and that meta-skill can rust and wither away, too, if it languishes unused. If you’ve been doing the very same thing at work for the last few years, without working on any side projects of your own, then I am sorry to report that your career is already rotting away from within, without you even knowing it.




 I'm at a tech conference. It's a session on React Native, and the presenter is convincing us why it's truly the "next big thing" for mobile development. To me, it seems a bit like JSPs of 15 years ago, with all the logic in the presentation code, but I'm "old", so I assume I just don't "get it".

As someone who just recently got the hang of Angular, it all makes me feel a little disheartened. "Here we go again", I think.

Of course I'm not really surprised. Over the past 20 years, I've taken seats on a number of band wagons, and have generally enjoyed the rides. The buzz that comes with a new "disruption" in programming can be exciting - feeling apart of a community of technical innovaters, championing something that will make things a little easier, quicker, cleaner, better. It can be fun. But on this particular morning, at the cusp of 40, I have to admit I feel a little drained. I know this is part of the job - if I want to stay relevant (and well paid), I know that every so often I need to cast out some of the knowledge that I've so dutifully absorbed, and gear up up for the next journey. It's just how it is.

As I think about it though, this regular ritual of my programming career doesn't seem to be a way of life for other professionals. The doctor at 40 doesn't seem to be worried about discovering that all his knowledge of the vascular system is about to evaporate in favor of some new organizing theory. The same goes for the lawyer, the plumber, the accountant, or the english teacher. While there are certainly unappealing aspects to these professions, it's safe to say that for each of them, mid-way through their career, the knowledge they've accumulated is relatively stable, and has afforded them with some increased measure of respect and compensation. In programming though, 20 years of experience does not seem to confer those same advantages.

Of course not all is so dismal in our profession - there are so many things to love about being a programmer - but in terms of the never-ending struggle to "keep up", it is an interesting feature that seems more or less unique to our field. Am I right though? Is programming really different in this regard? And if it is, then why? And what does it mean for our career trajectory? I'd like to try to answer all of this (because, why not) in terms of two concepts.

The first is knowledge decay. Everything we know, not just about programming, has an expiration; a point at which it is no longer useful. I learned how to drive a car when I was 16, and for that most part, that knowledge still serves me well. This piece of knowledge could be said to have a long half-life. For many professionals, their domain knowledge also has a relatively long half-life. Sure, new discoveries in medicine may displace some existing procedures, but likely there will not be a major overhaul in our understanding of our biology. When the expiration is long like this, knowledge can effectively be considered cumulative. The doctor is more knowledgeable than he was last year, because everything he learned in the past 12 months built on all that he knew before.

In programming, for good or bad, I'd assert that this is not exactly the case. Putting a (rather arbitrary) stake in the ground, I'd say that:

Half of what a programmer knows will be useless in 10 years.

This brings me to the second concept, knowledge accumulation rate - the pace at which we add new things to our knowledge corpus. In every field, there is a certain threshold of knowledge that must be met in order to be "certified" (or at least hireable), and the early portion of a career is typically dedicated to acquiring this knowledge. In programming, however, because of the fast decay of knowledge, it seems like we never really transcend the "student" period. We know we must always be learning, and this makes the stages of our career a bit atypical.



In the beginning of our careers, in what we could call the eager apprentice stage, accumulating knowledge is relatively easy. Everything is new, and so each experience is a vehicle to gain more knowledge. Moreover, since we're younger, we often have fewer hard obligations, and so we probably don't mind spending a few nights and weekends picking up new languages and frameworks. Lastly, and importantly, the expectations on us from our employers is lower. Everyone understands that we're junior, and so more easily than our colleagues, we can carve out a little time during the work day to fill in holes in our knowledge. This is a fun stage, but there's this persistent feeling that there's so much we don't know.

At some point though we cease to be novices, and we establish ourselves as productive, self-sufficient developers. For the first time, the gap between us and our colleagues (even the ones 10 years our senior!) does not seem so large. This fills us with vim and vigor, and so this is the rising star stage. The investment we made in learning has paid off, and just about everything we know is still useful - i.e. none of our knowledge has noticeably decayed. With this reservoir full of relevant knowledge, we begin to earn the respect of clients, peers, and managers, and with this respect comes titles, salary, and opportunities. Though we don't necessarily see it at the time, this is also an important point of inflection.

It's at this point that two things happen. First, that promotion to "senior" comes with something more than just money: greater expectations. Employers need their star programmers to be leaders - to help junior developers, review code, perform interviews, attend more meetings, and in many cases to help maintain the complex legacy software they helped build. All of this is eminently reasonable, but it comes, subtly, at the expense of our knowledge accumulation rate. The time we used to have to read tech blogs: gone. Second, it's also at this point that we first experience (or at least recognize) a little knowledge decay. Some of what we learned early in our career is now out-dated. All that time "we" (read: I) spent learning GWT? Lost! Essentially, both forces, knowledge decay and knowledge accumulation rate, begin to work against us.

It's at this point where we enter the third and final stage, the ebb-and-flow of the steady veteran. We are knowledgeable and productive, yes, but we also understand that we may actually know fewer (useful) things than we did at a prior point in our career. A non-trivial amount of our knowledge has decayed, and we may not have had the time to accumulate enough new knowledge to compensate. This can be frustrating, and I think it's why it's at this point that so many of us bail for other pastures - management, sales, testing, or (my dream) farming. We realize that it'll require real effort to just maintain our level proficiency - and without that effort, we could be worse at our jobs in 5 years than we are today. There is no coasting.




Humble Advice

This is where I'm at. I still love to learn, but I appreciate that without some herculean effort, I will probably always remain in an equilibrium state hovering around the lower boundary of "expert". I'm ok with this, because I enjoy my personal life more than I want to be the next Martin Fowler (although I bet Martin has a kick-ass personal life too - that guy is amazing). Thinking about my career in terms of knowledge decay and accumulation though has changed my perspective a little.

First, I try to take the long view. I'm more wary of roles with excessively taxing expectations and few opportunities for novel experiences. I've seen quite a few colleagues take the bigger pay check at an employer where there'll be little opportunity to work with new things and learn. In 5 years, they realize that much of their valuable knowledge has evaporated and their pay is way out of whack with their actual worth. In some cases, I think making less money in the short term (at a better employer) will yield more money (and stability) over the course of a long career.

Second, given that time is limited, I try to invest most in knowledge that is durable. My energy is better spent accumulating knowledge that has a longer half-life - algorithms, application security, performance optimization, and architecture. Carving out niches in these areas, I hope, will better bullet-proof my career than learning the newest, flash-in-the-pan Javascript library.

In the end, perhaps I haven't really forged any new ground here, but it's been useful for me to think about my career in terms of these two things: knowledge decay and knowledge accumulation. I'd love to hear any thoughts you have!










The software development complexity is increasing day by day. Almost every year a new framework (like AngularJS, ReactJS) is released, new build tool (like Webpack, Rollup). Even new JavaScript versions (ECMAScript 2015, 2016 and soon 2017) are released every year!

Generally the same situation exists in other fields of software development. 
For example mobile applications. 2 years ago Apple introduced a new programming language Swift. The iOS operating system releases a new version almost every year with new APIs and features.

This is great for software industry. But is a big load for us, software developers.

Unfortunately human intellectual possibilities are impressive... but limited. You cannot (and should not) know all the new frameworks and build tools.

What a software developer can do? The solution is to apply an efficient learning strategy: put accept on programming fundamentals.


The programming fundamentals consist of algorithms, data structures and programming language knowledge.
If you want to be a great software developer, without doubt you should constantly master trending technologies (like React, Redux, Angular). And in the meantime put the same amount of effort to learn regularly fundamentals like algorithms, data structures, the principles of writing scaling and clean code.


1. 1. The concept
An important part of the programming fundamentals are the algorithms. An algorithm is a step-by-step description of operations that should be performed to obtain a result.

The common categories of algorithms that you should know:

Sorting algorithms: bubble sort, insertion sort, quick sort, etc
Search algorithms: binary search, breadth-first search, depth-first search, etc
Shortest path algorithms: Bellman–Ford algorithm, Dijkstra's algorithm, etc
Math algorithms: Fibonacci numbers sequence, greatest common divisor, least common multiple, etc

When it comes to learning algorithms, the first reason I hear is that developer doesn't need to know exactly how specific algorithm works. You may think that all existing algorithms are already implemented, tested and included in standard libraries. 

Learning algorithms in details is a valuable experience. Studying and mastering them cultivates an intuition to solve difficult issues.

Powerful intuition is what defines a great software developer. Of course alongside with experience and discipline.

Data structures are an essential aspect too. Learning them teaches how to correctly represent the information in an application.

The correctly chosen data structure has huge benefits. It makes the code that manages data simpler to write and maintain. The operations of data manipulation, storage, query are easier to implement.

The quality code consists of an effective algorithm and convenient data structure.

2. Beginner: the upside-down triangle
For an easier representation lets divide coding abilities into a simplified scheme:

Fundamentals: everything related to algorithms, data structures, computer science questions, application design principles (SOLID, KISS, DRY, SoC), scalability
Language: everything related to programming languages (JavaScript, Swift, Java), the syntax, operators, variables, compilers
Framework: everything related to frameworks (AngularJS, ReactJS, Cocoa Touch) and platforms (Browser, NodeJS).
The first level of software development mastery is the beginner, which is represented by an upside-down triangle.

3. Proficient: the rectangle

4. Expert: the triangle
The upper level is an expert developer, which mastered all 3 directions: fundamentals, the language and framework. He is represented by a triangle with a solid base.

The expert developer is able to see the efficiency of certain algorithms and apply them when necessary. He benefits from choosing correct data structures, making data manipulations simple.

The challenge is to select from available algorithms the most efficient for a concrete situation. It is a process of balancing to obtain the maximum possible performance.

Since the programming language is an instrument to speak the algorithmic mind, it doesn't matter in what language developer writes. An expert can use several languages: JavaScript & Ruby, or C++ & Java.

5. Recommendations
Trending frameworks or even languages will be gone sooner or later. They will be replaced with better tools: an inevitable result of evolution. What you can do is put an accent on fundamentals.

Certainly the fundamentals are tough to learn. Many algorithms are hard to understand and remember. My suggestion is just have fun: you may read a complicated algorithm many times. Think what benefits may bring a specific data structure. Challenge yourself to become better and better.
